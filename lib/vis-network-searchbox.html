<h1>$title</h1>
<p>$description</p>
<input type="text" id="search-box" placeholder="Enter search term(s) divided by ';'" autocomplete="off">
<br><select id="multi-select" multiple="multiple"></select>
<datalist id="steplist"></datalist>
<br><span id="slider-value" style="width: 30px;display: inline-block;">1</span>&nbsp;
<input style="width:300px" type="range" class="slider" id="edge-value-slider" list="steplist" value="1"></input>
<style>
    #search-box { width: 600px}
    #multi-select {
        height: 100px;
        width: 600px;
    }
</style>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        const container = document.getElementsByClassName("vis-network")[0]
        const network = container.parentElement.chart
        const nodes = network.body.data.nodes;
        const edges = network.body.data.edges;
        const multiSelect = document.getElementById("multi-select");
        const searchBox = document.getElementById("search-box");
        const slider = document.getElementById("edge-value-slider");
        const datalist = document.getElementById('steplist');
        const storageId = "network-slider-value"

        // populate selectbox
        nodes.forEach(node => {
            const option = document.createElement("option");
            option.value = node.id;
            option.text = node.label;
            multiSelect.appendChild(option);
        })

        // filter options depending on user input
        const options = Array.from(multiSelect.options);
        searchBox.addEventListener("input", () => {
            const searchValues = searchBox.value.toLowerCase().split(";").map(s => s.trim());
            options.forEach(option => {
                const optionText = option.text.toLowerCase();
                const found = searchValues.some(searchValue => optionText.includes(searchValue))
                option.style.display = found ? "" : "none";
            });
        });

        // react to un/selection in the selectbox
        let updateTimeout;
        multiSelect.addEventListener("change", () => {
            clearTimeout(updateTimeout)
            slider.value = slider.min
            updateTimeout = setTimeout(updateNetwork, 500)
        });

        // on slider value change, show only
        slider.addEventListener('change', updateNetwork);

        // and update the display
        slider.addEventListener('input', displaySliderValue)

        // the default slider value comes either from the "min_edge_value" query param,
        // the local storage (to persist across pages), or a value passed to the script
        const defaultValue = parseInt(new URLSearchParams(document.location.search).get('min_edge_value'))
        || parseInt(window.localStorage.getItem(storageId)) || 0
        let max = updateSliderTicks()
        slider.value = Math.min(defaultValue, max);
        displaySliderValue()

        // doubleClick on nodes to expand neigboring nodes, not working
        network.on('doubleClick', expandNode);

        function displaySliderValue() {
            let value = slider.value;
            document.getElementById("slider-value").innerText = value
            window.localStorage.setItem(storageId, value);
        }

        // update the network depending on UI state (selectbox, slider, manual node selection)
        function updateNetwork () {
            // show/hide edges based on value
            let sliderValue = Number(slider.value);
            displaySliderValue()

            edgesToUpdate = edges.map(edge => ({
                id: edge.id,
                hidden: edge.value < sliderValue
            }))
            edges.update(edgesToUpdate)
            updateSliderTicks()

            // create a set of ids of nodes that have visible edges connected to it
            const updatedEdges = edges.get();
            const visibleNodeIds = new Set();
            updatedEdges.forEach(edge => {
                if (!edge.hidden) {
                    visibleNodeIds.add(edge.from);
                    visibleNodeIds.add(edge.to);
                }
            });

            // remove those which are not selected in the select box, if a selection has been made
            const selectedIds = Array.from(multiSelect.selectedOptions)
                    .filter(option => option.style.display != "none")
                    .map(option => Number(option.value));

            if (selectedIds.length > 0) {
                visibleNodeIds.forEach(id => {
                    if (!selectedIds.includes(id)) {
                        visibleNodeIds.delete(id)
                    }
                })
            }

            // create a array of nodes to be updated
            const nodesToUpdate = nodes.get().map(node => ({
                id: node.id,
                hidden: !visibleNodeIds.has(node.id)
            }));

            const visibleNodes = nodes.get().filter(node => !node.hidden)

            // update the nodes
            nodes.update(nodesToUpdate);

            // Center the view around the remaining visible nodes
            if (visibleNodeIds.size > 0) {
                network.fit({
                    nodes: Array.from(visibleNodeIds),
                    animation: {
                        duration: 500,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            }
        };

        // configure the slider ticks based on an arry of edges having a "value" property
        // returns the max value of the edges
        function updateSliderTicks() {
            // determine highest and lowest value of the visible edges
            let visibleEdges = edges.get().filter(edge => !edge.hidden);
            let min = 1;
            let max = Math.max(...edges.get().map(edge => edge.value));
            // dynamically determine the slider options (=ticks)
            let steps = [1, 2, 5, 10, 25, 50, 100, 500, 1000];
            let maxOptions = 10;
            let delta = max - min;
            let step;
            for(let s of steps) {
                step = s;
                if(Math.ceil(delta / s) <= maxOptions) break;
            }

            // no need to update anything
            if (slider.min == min && slider.max == max) {
                return
            }

            // configure the slider
            slider.min = min;
            slider.max = max;

            // remove the datalist options
            while (datalist.firstChild) {
                datalist.removeChild(dataList.firstChild);
            }

            // Start from the nearest higher multiple of step
            let start = Math.floor(min / step) * step;
            for (let i = start; i <= max; i += step) {
                let option = document.createElement('option');
                option.value = Math.max(i,min);
                datalist.appendChild(option);
            }
            return max;
        }

        function fitNetwork(nodes) {
            network.fit({
                nodes,
                animation: {
                    duration: 500,
                    easingFunction: 'easeInOutQuad'
                }
            });
        }

        function expandNode(params) {
            if (params.nodes.length > 0) {
                const nodeId = params.nodes[0];

                // Get connected nodes and edges
                const connectedNodes = network.getConnectedNodes(nodeId)
                    .map(id => Number(id));
                const connectedEdges = network.getConnectedEdges(nodeId);

                // Show connected nodes
                if (connectedNodes.length > 0) {
                    let nodesToUpdate = connectedNodes.map(neighborId => ({
                        id: neighborId,
                        hidden: false
                    }));
                    nodes.update(nodesToUpdate)
                    //fitNetwork(nodesToUpdate)
                }

                // Show connected edges
                if (connectedEdges.length > 0) {
                    const edgesToUpdate = connectedEdges.map(edgeId => {
                        const edge = edges.get(edgeId);
                        edge.hidden = false;
                        return edge;
                    });
                    edges.update(edgesToUpdate);
                }

                // Temporarily enable physics
                network.setOptions({ physics: true });

                // Disable physics after stabilization
                network.once("stabilized", function() {
                    network.setOptions({ physics: false });
                });
            }
        }

    });
</script>

