<div id="title">$title</div>
<button id="toggle-button">Show/hide Search</button>

<div id="popup">
    <fieldset>
        <legend>Journals</legend>
        <input id="search-box" type="text" placeholder="Enter search term(s) divided by ';'">
        <select id="journal-select" multiple="multiple"></select>
        <datalist id="steplist"></datalist>
    </fieldset>
    <fieldset>
        <legend>Minimum number of citations</legend>
        <div id="edge-value-setter">
            <input id="edge-value-input" value="1">
            <input id="edge-value-slider" type="range" list="steplist" value="1">
            <button id="edge-value-reset">Reset</button>
        </div>
    </fieldset>
    <fieldset>
        <legend>Groups</legend>
        <select id="group-select" multiple="multiple"></select>
    </fieldset>
    <fieldset>
        <legend>More information</legend>
        <a href="$file_journal_table" target="_blank">Journals</a> |
        <a href="$file_group_table" target="_blank">Journal Groups</a> |
        <a href="$file_communities" target="_blank">Community Graph</a>
    </fieldset>
</div>

<script>
    document.getElementById('toggle-button').addEventListener('click', function() {
        var popup = document.getElementById('popup');
        popup.classList.toggle('show');
    });
</script>

<script id="group-data" type="application/json">$groups</script>

<style>
    #toggle-button {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 1001;
        padding: 3px;
    }

    #popup {
        position: fixed;
        top: 50px;
        left: 20px;
        width: 300px;
        padding: 5px;
        font-family: inherit;
        border: 1px solid #ddd;
        background-color: white;
        box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5);
        display: none;
        z-index: 1000;
        font-family: Arial !important;
        font-size: small !important;
    }

    #popup.show {
        display: block;
    }

    #search-box {
        width: 100%;
        margin-bottom: 5px;
    }

    #journal-select, #group-select {
        height: 200px;
        width: 100%;
    }

    #edge-value-setter {
        display: flex; /* Enables flexbox layout */
        width: 100%; /* Ensures the container fills its parent */
    }

    #edge-value-input {
        width: 40px;
        flex-shrink: 0;
        margin-right: 10px;
    }

    #edge-value-reset {
        width: 50px;
        flex-shrink: 0;
        margin-left: 10px;
    }

    #edge-value-slider {
        flex-grow: 1;
    }


    #title {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1001;
    }

    [id^="selectedByhtmlwidget"] {
        position: fixed;
        top: 20px;
        left: 200px;
        z-index: 1001;
    }

    .node-title-label: {
        font-weight: bold !important;
    }


</style>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        const container = document.getElementsByClassName("vis-network")[0]
        const network = container.parentElement.chart
        const nodes = network.body.data.nodes;
        const edges = network.body.data.edges;
        const searchBox = document.getElementById("search-box");
        const journalSelect = document.getElementById("journal-select");
        const edgeValueSlider = document.getElementById("edge-value-slider");
        const edgeValueInput = document.getElementById("edge-value-input");
        const edgeValueReset = document.getElementById("edge-value-reset");
        const datalist = document.getElementById('steplist');
        const storageId = "network-slider-value"
        const groups = JSON.parse(document.getElementById('group-data').textContent)
        const groupSelect =  document.getElementById("group-select");

        // populate journal selectbox
        nodes.forEach(node => {
            const option = document.createElement("option");
            option.value = node.id;
            option.text = node.label.split("(")[0]; //  this needs a more robust
            journalSelect.appendChild(option);
        })

        // filter options depending on user input
        const options = Array.from(journalSelect.options);
        searchBox.addEventListener("input", () => {
            const searchValues = searchBox.value.toLowerCase().split(";").map(s => s.trim());
            options.forEach(option => {
                const optionText = option.text.toLowerCase();
                const found = searchValues.some(searchValue => optionText.includes(searchValue))
                option.style.display = found ? "" : "none";
            });
        });

        // react to un/selection in the selectbox
        let updateTimeout;
        journalSelect.addEventListener("change", () => {
            clearTimeout(updateTimeout)
            updateTimeout = setTimeout(updateNetwork, 500)
        });

        // on slider value change, show only
        edgeValueSlider.addEventListener('change', updateNetwork);

        // and update the display
        edgeValueSlider.addEventListener('input', evt => updateEdgeValue(evt.target.value))
        edgeValueInput.addEventListener('change', evt => updateEdgeValue(evt.target.value))

        // reset the min edge value
        edgeValueReset.addEventListener('click',  () => updateEdgeValue(1))

        // doubleClick on nodes to expand neigboring nodes
        /*network.on('doubleClick', params => {
            if (params.nodes.length > 0) {
                expandNode(params.nodes[0]);
            }
            return false
        });*/

        // populate group selectbox
        Object.keys(groups).forEach(key => {
            const option = document.createElement("option");
            option.value = key;
            option.text = key;
            groupSelect.appendChild(option);
        })

        groupSelect.addEventListener("change", () => {
            let journalsInGroups = []
            Array.from(groupSelect.selectedOptions).forEach(option => {
                groupName = option.value
                group = groups[groupName]
                journalsInGroups = journalsInGroups.concat(group)
            })
            if (journalsInGroups.length > 0) {
                Array.from(journalSelect.options).forEach(option => {
                    option.selected = journalsInGroups.includes(option.text)
                })
                updateNetwork();
            }
        });

        // configure UI state
        const params = new URLSearchParams(document.location.search)
        const store = window.localStorage
        const searchValue = params.get('search_value') || ''
        const selectedValues = (params.get('selected_values') || '').split('|')
        let sliderValue = parseInt(params.get('min_edge_value')) || parseInt(store.getItem(storageId)) || 1
        let max = updateSliderTicks()

        sliderValue = Math.min(sliderValue, max);
        searchBox.value = searchValue
        Array.from(journalSelect.options).forEach(option => {
            option.selected = selectedValues.includes(option.text);
        });
        updateEdgeValue(sliderValue)
        fitNetwork()

        //=============== functions ===============

        function updateEdgeValue(value) {
            if (edgeValueSlider.value !== value || edgeValueInput.value !== value){
                edgeValueSlider.value = value;
                edgeValueInput.value = value
                window.localStorage.setItem(storageId, value);
                updateNetwork()
            }
        }

        // update the network depending on UI state (selectbox, slider, manual node selection)
        function updateNetwork () {

            // show/hide edges based on value
            let sliderValue = Number(edgeValueSlider.value);

            edgesToUpdate = edges.map(edge => ({
                id: edge.id,
                hidden: edge.value < sliderValue
            }))
            edges.update(edgesToUpdate)
            updateSliderTicks()

            // create a set of ids of nodes that have visible edges connected to it
            const updatedEdges = edges.get();
            const visibleNodeIds = new Set();
            updatedEdges.forEach(edge => {
                if (!edge.hidden) {
                    visibleNodeIds.add(Number(edge.from));
                    visibleNodeIds.add(Number(edge.to));
                }
            });

            // remove those which are not selected in the select box, if a selection has been made
            const selectedIds = Array.from(journalSelect.selectedOptions)
                .filter(option => option.style.display != "none")
                .map(option => Number(option.value));

            if (selectedIds.length > 0) {
                visibleNodeIds.forEach(id => {
                    if (!selectedIds.includes(id)) {
                        visibleNodeIds.delete(id)
                    }
                })
            }

            // create a array of nodes to be updated
            const nodesToUpdate = nodes.get().map(node => ({
                id: node.id,
                hidden: !visibleNodeIds.has(node.id)
            }));

            // update the nodes
            nodes.update(nodesToUpdate);
        };

        function fitNetwork() {
            const visibleNodeIds = nodes.get().filter(node => !node.hidden).map(node => node.id)
            // Center the view around the remaining visible nodes
            if (visibleNodeIds.length > 0) {
                network.fit({
                    nodes: visibleNodeIds,
                    animation: {
                        duration: 500,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            }
        }

        // configure the slider ticks based on an arry of edges having a "value" property
        // returns the max value of the edges
        function updateSliderTicks() {
            // determine highest and lowest value of the visible edges
            let visibleEdges = edges.get().filter(edge => !edge.hidden);
            let min = 1;
            let max = Math.max(...edges.get().map(edge => edge.value));

            // no need to update anything
            if (edgeValueSlider.min == min && edgeValueSlider.max == max) {
                return
            }

            // remove the datalist options
            while (datalist.firstChild) {
                datalist.removeChild(dataList.firstChild);
            }

            // configure the slider
            edgeValueSlider.min = min;
            edgeValueSlider.max = max;

            // dynamically determine the slider options (=ticks)
            let steps = [1, 2, 5, 10, 25, 50, 100, 500, 1000];
            let maxOptions = 10;
            let delta = max - min;
            let step;
            for(let s of steps) {
                step = s;
                if(Math.ceil(delta / s) <= maxOptions) break;
            }
            // Start from the nearest higher multiple of step
            let start = Math.floor(min / step) * step;
            for (let i = start; i <= max; i += step) {
                let option = document.createElement('option');
                option.value = Math.max(i,min);
                datalist.appendChild(option);
            }
            return max;
        }

        function expandNode(nodeId) {

            // Get connected nodes and edges
            const connectedNodeIds = network.getConnectedNodes(nodeId);
            const connectedEdgeIds = network.getConnectedEdges(nodeId);

            // Show connected edges depending on slider value
            if (connectedEdgeIds.length > 0) {
                const edgesToUpdate = connectedEdgeIds.map(edgeId => {
                    const edge = edges.get(edgeId);
                    edge.hidden = edge.value < Number(edgeValueSlider.value);
                    return edge;
                });
                edges.update(edgesToUpdate);
            }
            // Show connected nodes depending on whether they have visible edges
            const visibleNodeIds = new Set();
            connectedEdgeIds.forEach(edgeId => {
                const edge = edges.get(edgeId);
                if (!edge.hidden) {
                    visibleNodeIds.add(edge.from);
                    visibleNodeIds.add(edge.to);
                }
            });
            const nodesToUpdate = connectedNodeIds.map(nodeId => {
                const node = nodes.get(nodeId)
                node.hidden = !visibleNodeIds.has(node.id)
                return node
            })
            nodes.update(nodesToUpdate)
        }

        function resolveOverlaps(nodes, minDistance=200, maxDistance=1000, timeout = 5000) {
            let startTime = Date.now();
            let elapsed = 0;
            let changed = true;

            while (changed && elapsed < timeout) {
                changed = false;

                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        let node1 = nodes[i];
                        let node2 = nodes[j];

                        let dx = node2.x - node1.x;
                        let dy = node2.y - node1.y;
                        let distance = Math.sqrt(dx * dx + dy * dy);

                        // Nodes are too close
                        if (distance < minDistance) {
                            changed = true;

                            let angle = Math.atan2(dy, dx);
                            let moveDistance = (minDistance - distance) / 2.0;

                            node1.x -= moveDistance * Math.cos(angle);
                            node1.y -= moveDistance * Math.sin(angle);
                            node2.x += moveDistance * Math.cos(angle);
                            node2.y += moveDistance * Math.sin(angle);
                        }
                        // Nodes are too far
                        else if (distance > maxDistance) {
                            changed = true;

                            let angle = Math.atan2(dy, dx);
                            let moveDistance = (distance - maxDistance) / 2.0;

                            node1.x += moveDistance * Math.cos(angle);
                            node1.y += moveDistance * Math.sin(angle);
                            node2.x -= moveDistance * Math.cos(angle);
                            node2.y -= moveDistance * Math.sin(angle);
                        }
                    }
                }

                // Update the elapsed time
                elapsed = Date.now() - startTime;
            }

            if (elapsed >= timeout) {
                console.warn("Time limit reached before resolving all overlaps and separations");
            }
        }

        function distributeNodesRadially(centerNodeId, connectedNodes, minDistance = 100) {

            // Fetch the central node
            const centerNode = nodes.get(centerNodeId);

            // Determine the angle step based on the number of nodes
            const angleStep = 2 * Math.PI / connectedNodes.length;

            // Distribute nodes radially
            const nodesToUpdate = connectedNodes.map((node, index) => {
                const angle = index * angleStep;
                return {
                    id: node.id,
                    x: centerNode.x + minDistance * Math.cos(angle),
                    y: centerNode.y + minDistance * Math.sin(angle),
                    hidden: false
                };
            });

            nodes.update(nodesToUpdate);

            network.redraw()
        }


        // not working
        function showSubgraph(params) {
            if (params.nodes.length > 0) {
                const nodeId = params.nodes[0];

                // Get connected nodes and edges
                const connectedNodes = network.getConnectedNodes(nodeId);
                const connectedEdges = network.getConnectedEdges(nodeId);

                // Update connected nodes to be visible
                const nodesToUpdate = connectedNodes.map(id => ({ id, hidden: false }));
                nodes.update(nodesToUpdate);

                // Update connected edges to be visible
                const edgesToUpdate = connectedEdges.map(id => ({ id, hidden: false }));
                edges.update(edgesToUpdate);

                // Backup hidden nodes and remove them temporarily
                const hiddenNodes = nodes.get({ filter: node => node.hidden });
                nodes.remove(hiddenNodes.map(node => node.id));

                // Enable physics and let it stabilize the remaining nodes
                network.setOptions({ physics: {
                    enabled: true,
                    solver: 'repulsion',
                    repulsion: {
                        nodeDistance: 500,
                        centralGravity: 0.1
                    }
                } });

                network.once("stabilized", function() {
                    // Restore the hidden nodes
                    //nodes.add(hiddenNodes);

                    // Disable physics
                    network.setOptions({ physics: false });
                });
            }
        }


    });
</script>

