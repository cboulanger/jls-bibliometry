<div id="title">$title</div>
<button id="toggle-button">Show/hide Search</button>
<div id="popup">
    <fieldset>
        <legend>Journals</legend>
        <div class="container">
            <input id="search-box" type="text" placeholder="Enter search term(s) divided by ';'">
            <button id="search-box-reset">Reset</button>
        </div>
        <select id="journal-select" multiple="multiple"></select>
    </fieldset>
    <fieldset>
        <legend>Minimum yearly citations ratio: <span id="min-cit-ratio"></span></legend>
        <div class="container">
            <input id="edge-value-input" value="1">
            <datalist id="steplist"></datalist>
            <input id="edge-value-slider" type="range" list="steplist" value="1">
            <button id="edge-value-reset">Reset</button>
        </div>
    </fieldset>
    <fieldset>
        <legend>Groups</legend>
        <select id="group-select" multiple="multiple"></select>
    </fieldset>
    <fieldset>
        <legend>More information</legend>
        <p>$description</p>
        <p>
            <a href="$file_journal_table" target="_blank">Table of journals</a> |
            <a href="$file_group_table" target="_blank">Table of journal groups</a> |
            <a href="$file_communities" target="_blank">Graph of communities</a> |
            Distribution of yearly citation ratios: <a href="$file_distribution_normalized_weights" target="_blank">Median</a>,
            <a href="$file_distr_scaled_adj_log_transf_norm_weights" target="_blank">Scaled adjusted log-transformed</a>
        </p>

    </fieldset>
</div>

<!-- data -->
<script id="group-data" type="application/json">$groups</script>
<script id="scaled-to-ratio" type="application/json">$scaled_to_ratio</script>

<style>

    body {
        padding: 0px !important;
    }

    #title {
        position: fixed;
        font-weight: bold;
        top: 20px;
        right: 20px;
        z-index: 1001;
    }

    #toggle-button {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 1001;
        padding: 3px;
    }

    #popup {
        position: fixed;
        top: 50px;
        left: 20px;
        width: 30vw;
        min-width: 300px;
        padding: 5px;
        font-family: inherit;
        border: 1px solid #ddd;
        background-color: white;
        box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5);
        display: none;
        z-index: 1000;
        font-family: Arial !important;
        font-size: small !important;
    }

    #popup.show {
        display: block;
    }

    #search-box {
        width: 100%;
        margin-bottom: 5px;
    }

    #journal-select, #group-select {
        height: 200px;
        width: 100%;
    }

    #group-select {
        height: 150px;
    }

    .container {
        display: flex;
        width: 100%;
    }

    #edge-value-input {
        display: none;
        width: 30px;
        flex-shrink: 0;
        margin-right: 10px;
    }

    #edge-value-slider,
    #search-box {
        flex-grow: 1;
        flex-shrink: 1;
        flex-basis: auto; /* or you can set a specific value */
        min-width: 100px;
    }

    #edge-value-reset,
    #search-box-reset {
        width: 50px;
        height: 30px;
        flex-shrink: 0;
        margin-left: 10px;
    }

    [id^="selectedByhtmlwidget"] {
        position: fixed;
        top: 20px;
        left: 200px;
        z-index: 1001;
    }

    .node-title-label: {
        font-weight: bold !important;
    }
</style>

<script type="text/javascript">

    document.addEventListener("DOMContentLoaded", function() {
        const byId = document.getElementById.bind(document);
        const container = document.getElementsByClassName("vis-network")[0]
        const network = container.parentElement.chart
        const nodes = network.body.data.nodes;
        const edges = network.body.data.edges;
        const groups = JSON.parse(byId('group-data').textContent)
        const scaled_to_ratio = JSON.parse(byId('scaled-to-ratio').textContent)

        // UI
        const toggleButton = byId('toggle-button');
        const popup = byId('popup');
        const searchBox = byId("search-box");
        const searchBoxReset = byId("search-box-reset");
        const journalSelect = byId("journal-select");
        const minCitRatio = byId("min-cit-ratio");
        const edgeValueSlider = byId("edge-value-slider");
        const edgeValueInput = byId("edge-value-input");
        const edgeValueReset = byId("edge-value-reset");
        const datalist = byId('steplist');
        const groupSelect =  byId("group-select")

        // Helper class to persist values in the URL hash
        class UrlHash {
            // Parses the current URL hash into a key-value map
            static parseHash() {
                const hash = window.location.hash.substring(1);
                const entries = hash.split('|').filter(entry => entry.includes(':'));
                return new Map(entries.map(entry => {
                    const [key, value] = entry.split(':');
                    return [key, decodeURIComponent(value)];
                }));
            }

            // Serializes the key-value map back into a hash string
            static serializeHash(map) {
                return Array.from(map.entries()).map(entry => {
                    const [key, value] = entry;
                    return `${key}:${encodeURIComponent(value)}`;
                }).join('|');
            }

            // Sets a value in the URL hash for the given key
            static set(key, value) {
                const map = this.parseHash();
                map.set(key, value); // No encoding here, it's done in serializeHash
                window.location.hash = this.serializeHash(map);
            }

            // Retrieves a value from the URL hash for the given key
            // Returns the default value if the key is not found
            static get(key, defaultValue = undefined) {
                const map = this.parseHash();
                return map.has(key) ? map.get(key) : defaultValue;
            }

            // Removes a key (and its associated value) from the URL hash
            static remove(key) {
                const map = this.parseHash();
                if (map.has(key)) {
                    map.delete(key);
                    window.location.hash = this.serializeHash(map);
                }
            }
        }

        //  popup toggle button
        toggleButton.addEventListener('click', () => popup.classList.toggle('show'));

        // populate journal selectbox
        nodes.forEach(node => {
            const option = document.createElement("option");
            option.dataset.group = node.group
            option.value = node.id;
            option.text = node.label.split("(")[0]; //  this needs a more robust
            journalSelect.appendChild(option);
        })

        // filter options depending on user input
        const options = Array.from(journalSelect.options);
        searchBox.addEventListener("input", filterJournals);

        // react to un/selection in the selectbox
        let updateTimeout;
        journalSelect.addEventListener("change", () => {
            clearTimeout(updateTimeout)
            updateTimeout = setTimeout(updateNetwork, 500)
            let selectedIds = Array.from(journalSelect.selectedOptions).map(o => o.value)
            UrlHash.set('selectedJournals', selectedIds.join(","))
        });

        // reset the search box, the journal select box and the group select box
        searchBoxReset.addEventListener('click',  () => resetJournalFilter())

        // populate the slider data list
        for (let i = 0; i < 100; i++) {
            if (scaled_to_ratio[i]) {
                let option = document.createElement('option');
                option.value = i+1;
                datalist.appendChild(option);
            }
        }

        // on slider value change, show only
        edgeValueSlider.addEventListener('change', updateNetwork);

        // and update the display
        edgeValueSlider.addEventListener('input', evt => updateEdgeValue(evt.target.value, false))
        edgeValueInput.addEventListener('change', evt => updateEdgeValue(evt.target.value, true))

        // reset the min edge value
        edgeValueReset.addEventListener('click',  () => updateEdgeValue(1, true))

        // doubleClick on nodes to show neigboring nodes
        network.on('click', params => params.nodes.length > 0 && showConnectedNodes(params.nodes[0]));

        // populate group selectbox
        groups.forEach((key, index) => {
            const option = document.createElement("option");
            option.value = index+1;
            option.text = key;
            groupSelect.appendChild(option);
        })

        groupSelect.addEventListener("change", () => {
            searchBox.value = ""
            let groups = Array.from(groupSelect.selectedOptions).map(o => Number(o.value))
            Array.from(journalSelect.options).forEach(option => {
                option.selected = groups.includes(Number(option.dataset.group))
                option.style.display = option.selected ? "" : "none";
            })
            updateNetwork()
            fitNetwork()
        });

        // configure UI state from hash values

        // search box
        let searchText = UrlHash.get('search', '')
        if (searchText != "") {
            searchBox.value = searchText
            filterJournals()
        }

        // slider
        let minEdgeValue = parseInt(UrlHash.get('minEdgeValue', '1'))
        updateEdgeValue(minEdgeValue, true)

        // journal select box
        let selectedJournals = (UrlHash.get('selectedJournals', '')).split(',')
        if (selectedJournals.length > 0) {
            Array.from(journalSelect.options).forEach(option => {
                option.selected = selectedJournals.includes(option.value);
            });
            updateNetwork()
        }

        // fit network into viewport
        fitNetwork()

        //=============== functions ===============

        function filterJournals() {
            const searchValues = searchBox.value.toLowerCase().split(";").map(s => s.trim());
            options.forEach(option => {
                const optionText = option.text.toLowerCase();
                const found = searchValues.some(searchValue => optionText.includes(searchValue))
                option.style.display = found ? "" : "none";
            });
            UrlHash.set('search', searchBox.value)
        }

        function resetJournalFilter() {
            searchBox.value = "";
            Array.from(journalSelect.selectedOptions)
                .concat(Array.from(groupSelect.selectedOptions))
                .forEach(option =>  {
                option.selected = false
            })
            Array.from(journalSelect.options).forEach(option => option.style.display="")
            updateNetwork()
            fitNetwork()
            UrlHash.remove('search')
            UrlHash.remove('selectedJournals')
        }

        // given a value between 1-100, return the corresponding median yearly citation ratio or undefined if
        // no such value exists. if no value is passed, get it from the slider
        function getMinEdgeWeight(value) {
            value = value || parseInt(edgeValueSlider.value)
            return scaled_to_ratio[value-1]
        }

        function updateEdgeValue(value, update=false) {
            if (edgeValueSlider.value !== value || edgeValueInput.value !== value){
                edgeValueSlider.value = value;
                edgeValueInput.value = value
                let minWeight = getMinEdgeWeight(value)
                minCitRatio.innerHTML = String(minWeight)
                if (update) {
                    updateNetwork()
                }
            }
            UrlHash.set('minEdgeValue', value)
        }

        // update the network depending on UI state (selectbox, slider, manual node selection)
        function updateNetwork() {

            let minWeight = getMinEdgeWeight() || 0;
            console.log(`Updating network with minimum edge weight of ${minWeight}...`)

            // show/hide edges based on value
            edgesToUpdate = edges.map(edge => ({
                id: edge.id,
                hidden: edge.value < minWeight
            }))
            edges.update(edgesToUpdate)

            // create a set of ids of nodes that have visible edges connected to it
            const updatedEdges = edges.get();
            const visibleNodeIds = new Set();
            updatedEdges.forEach(edge => {
                if (!edge.hidden) {
                    visibleNodeIds.add(Number(edge.from));
                    visibleNodeIds.add(Number(edge.to));
                }
            });

            // remove those which are not selected in the select box, if a selection has been made
            const selectedIds = Array.from(journalSelect.selectedOptions)
                .filter(option => option.style.display != "none")
                .map(option => Number(option.value));

            if (selectedIds.length > 0) {
                visibleNodeIds.forEach(id => {
                    if (!selectedIds.includes(id)) {
                        visibleNodeIds.delete(id)
                    }
                })
            }

            // create a array of nodes to be updated
            const nodesToUpdate = nodes.get().map(node => ({
                id: node.id,
                hidden: !visibleNodeIds.has(node.id)
            }));

            // update the nodes
            nodes.update(nodesToUpdate);
        };

        function fitNetwork() {
            const visibleNodeIds = nodes.get().filter(node => !node.hidden).map(node => node.id)
            // Center the view around the remaining visible nodes
            if (visibleNodeIds.length > 0) {
                network.fit({
                    nodes: visibleNodeIds,
                    animation: {
                        duration: 500,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            }
        }

        function showConnectedNodes(nodeId) {
            console.log(`Showing network of node #${nodeId}`)
            const nodeIds = network.getConnectedNodes(nodeId).map(id => Number(id))
            nodeIds.push(nodeId)
            Array.from(journalSelect.options).forEach(option => {
                if (nodeIds.includes(Number(option.value))) {
                    option.selected = true
                    option.style.display=""
                }
            })
            updateNetwork()
        }
    });
</script>

